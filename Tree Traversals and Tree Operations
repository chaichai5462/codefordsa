#include <iostream>
#include <queue>
using namespace std;

// Node structure
class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Insert node (Level Order insertion)
Node* insert(Node* root, int data) {
    if (root == nullptr) {
        return new Node(data);
    }
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        Node* temp = q.front();
        q.pop();

        if (temp->left == nullptr) {
            temp->left = new Node(data);
            break;
        } else {
            q.push(temp->left);
        }

        if (temp->right == nullptr) {
            temp->right = new Node(data);
            break;
        } else {
            q.push(temp->right);
        }
    }
    return root;
}

// Search element
bool search(Node* root, int key) {
    if (root == nullptr) return false;
    if (root->data == key) return true;
    return search(root->left, key) || search(root->right, key);
}

// Find height of tree
int height(Node* root) {
    if (root == nullptr) return -1; // empty tree height = -1
    return 1 + max(height(root->left), height(root->right));
}

// Count total nodes
int countNodes(Node* root) {
    if (root == nullptr) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// Count leaf nodes
int countLeafNodes(Node* root) {
    if (root == nullptr) return 0;
    if (root->left == nullptr && root->right == nullptr) return 1;
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

// Traversals
void preorder(Node* root) {
    if (root) {
        cout << root->data << " ";
        preorder(root->left);
        preorder(root->right);
    }
}

void inorder(Node* root) {
    if (root) {
        inorder(root->left);
        cout << root->data << " ";
        inorder(root->right);
    }
}

void postorder(Node* root) {
    if (root) {
        postorder(root->left);
        postorder(root->right);
        cout << root->data << " ";
    }
}

void levelOrder(Node* root) {
    if (!root) return;
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        Node* node = q.front();
        q.pop();
        cout << node->data << " ";
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
}

// -------- Main Program --------
int main() {
    Node* root = nullptr;

    // Insert nodes
    int values[] = {10, 20, 30, 40, 50};
    for (int v : values) {
        root = insert(root, v);
    }

    cout << "Search 30: " << (search(root, 30) ? "Found" : "Not Found") << endl;
    cout << "Height of tree: " << height(root) << endl;
    cout << "Total nodes: " << countNodes(root) << endl;
    cout << "Leaf nodes: " << countLeafNodes(root) << endl;

    cout << "\nPreorder Traversal:\n";
    preorder(root);
    cout << "\nInorder Traversal:\n";
    inorder(root);
    cout << "\nPostorder Traversal:\n";
    postorder(root);
    cout << "\nLevel Order Traversal:\n";
    levelOrder(root);

    return 0;
}
Output:
Search 30: True
Height of tree: 2
Total nodes: 5
Leaf nodes: 3

Preorder Traversal:
10 20 40 50 30 
Inorder Traversal:
40 20 50 10 30 
Postorder Traversal:
40 50 20 30 10 
Level Order Traversal:
10 20 30 40 50 
=== Code Execution Successful ===
